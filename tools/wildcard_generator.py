"""\nWildcard Generator Pro - Advanced prompt generation with wildcards system\n\nProfessional-grade wildcard management and prompt building for Stable Diffusion.\nSupports dynamic wildcards, weighted selections, and prompt templates.\n"""\n\nimport os\nimport json\nimport random\nimport re\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass WildcardGenerator:\n    """\n    Advanced wildcard generator for Stable Diffusion prompts.\n    \n    Features:\n    - Dynamic wildcard processing with weights\n    - Template-based prompt generation\n    - Category-based organization\n    - Import/export functionality\n    - Batch generation support\n    """\n    \n    def __init__(self, wildcards_dir: Optional[str] = None):\n        """Initialize wildcard generator."""\n        self.wildcards_dir = wildcards_dir or self._get_default_wildcards_dir()\n        self.wildcards_data: Dict[str, List[str]] = {}\n        self.templates: Dict[str, str] = {}\n        self.load_wildcards()\n        self.load_templates()\n    \n    def _get_default_wildcards_dir(self) -> str:\n        """Get default wildcards directory."""\n        base_dir = Path(__file__).parent.parent\n        wildcards_dir = base_dir / \"wildcards_data\"\n        wildcards_dir.mkdir(exist_ok=True)\n        return str(wildcards_dir)\n    \n    def load_wildcards(self) -> bool:\n        """Load wildcards from directory structure."""\n        try:\n            wildcards_path = Path(self.wildcards_dir)\n            if not wildcards_path.exists():\n                self._create_default_wildcards()\n                return True\n            \n            # Load .txt files as wildcard categories\n            for txt_file in wildcards_path.glob(\"**/*.txt\"):\n                category_name = txt_file.stem\n                with open(txt_file, 'r', encoding='utf-8') as f:\n                    lines = [line.strip() for line in f.readlines() if line.strip()]\n                    self.wildcards_data[category_name] = lines\n            \n            # Load JSON files for structured data\n            for json_file in wildcards_path.glob(\"**/*.json\"):\n                with open(json_file, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    if isinstance(data, dict):\n                        self.wildcards_data.update(data)\n            \n            logger.info(f\"Loaded {len(self.wildcards_data)} wildcard categories\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error loading wildcards: {e}\")\n            self._create_default_wildcards()\n            return False\n    \n    def _create_default_wildcards(self) -> None:\n        """Create default wildcard categories."""\n        default_wildcards = {\n            \"characters\": [\n                \"beautiful woman\", \"handsome man\", \"cute child\", \"elderly person\",\n                \"warrior\", \"mage\", \"archer\", \"knight\", \"princess\", \"prince\"\n            ],\n            \"environments\": [\n                \"forest\", \"mountain\", \"ocean\", \"desert\", \"city\", \"village\",\n                \"castle\", \"temple\", \"cave\", \"valley\", \"island\", \"ruins\"\n            ],\n            \"moods\": [\n                \"mysterious\", \"epic\", \"serene\", \"dramatic\", \"whimsical\", \"dark\",\n                \"bright\", \"romantic\", \"adventurous\", \"peaceful\", \"intense\", \"magical\"\n            ],\n            \"art_styles\": [\n                \"photorealistic\", \"oil painting\", \"watercolor\", \"digital art\",\n                \"concept art\", \"anime\", \"cartoon\", \"sketch\", \"impressionist\", \"abstract\"\n            ]\n        }\n        \n        self.wildcards_data = default_wildcards\n        self.save_wildcards()\n        logger.info(f\"Created {len(default_wildcards)} default wildcard categories\")\n    \n    def load_templates(self) -> None:\n        """Load prompt templates."""\n        self.templates = {\n            \"portrait\": \"{characters} portrait, {moods} mood, {art_styles} style\",\n            \"landscape\": \"{environments} landscape, {moods} atmosphere, {art_styles} style\",\n            \"fantasy\": \"{characters} in {environments}, {moods} fantasy scene, {art_styles}\",\n            \"artistic\": \"{characters}, {art_styles} style, {moods} composition\"\n        }\n    \n    def generate_variations(self, template: str, count: int = 5) -> List[str]:\n        """Generate multiple prompt variations from template."""\n        variations = []\n        for _ in range(count):\n            try:\n                variation = self.process_wildcards(template)\n                if variation and variation not in variations:\n                    variations.append(variation)\n            except Exception as e:\n                logger.warning(f\"Error generating variation: {e}\")\n                continue\n        \n        return variations\n    \n    def process_wildcards(self, template: str) -> str:\n        """Process wildcards in template string."""\n        if not template:\n            return \"\"\n        \n        # Find all wildcard patterns {category}\n        pattern = r'\\{([^}]+)\\}'\n        matches = re.findall(pattern, template)\n        \n        result = template\n        for match in matches:\n            category = match.strip()\n            if category in self.wildcards_data:\n                replacement = random.choice(self.wildcards_data[category])\n                result = result.replace(f\"{{{match}}}\", replacement, 1)\n            else:\n                # Remove unknown wildcards\n                result = result.replace(f\"{{{match}}}\", \"\")\n        \n        # Clean up extra spaces\n        result = re.sub(r'\\s+', ' ', result).strip()\n        return result\n    \n    def get_wildcard_categories(self) -> List[str]:\n        \"\"\"Get list of available wildcard categories.\"\"\"\n        return list(self.wildcards_data.keys())\n    \n    def get_wildcards_by_category(self, category: str) -> List[str]:\n        \"\"\"Get wildcards for specific category.\"\"\"\n        return self.wildcards_data.get(category, [])\n    \n    def add_wildcard_item(self, category: str, item: str) -> bool:\n        \"\"\"Add new item to wildcard category.\"\"\"\n        if not category or not item:\n            return False\n        \n        if category not in self.wildcards_data:\n            self.wildcards_data[category] = []\n        \n        if item not in self.wildcards_data[category]:\n            self.wildcards_data[category].append(item)\n            self.save_wildcards()\n            return True\n        \n        return False\n    \n    def save_wildcards(self) -> bool:\n        \"\"\"Save wildcards to JSON file.\"\"\"\n        try:\n            output_path = Path(self.wildcards_dir) / \"wildcards.json\"\n            with open(output_path, 'w', encoding='utf-8') as f:\n                json.dump(self.wildcards_data, f, indent=2, ensure_ascii=False)\n            \n            logger.info(f\"Saved wildcards to {output_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error saving wildcards: {e}\")\n            return False\n    \n    def get_template_options(self) -> List[str]:\n        \"\"\"Get available template names.\"\"\"\n        return list(self.templates.keys())\n    \n    def get_template(self, name: str) -> str:\n        \"\"\"Get template by name.\"\"\"\n        return self.templates.get(name, \"\")\n    \n    def analyze_template(self, template: str) -> Dict[str, Any]:\n        \"\"\"Analyze template and return metadata.\"\"\"\n        wildcards_used = re.findall(r'\\{([^}]+)\\}', template)\n        available_categories = self.get_wildcard_categories()\n        \n        valid_wildcards = [w for w in wildcards_used if w in available_categories]\n        invalid_wildcards = [w for w in wildcards_used if w not in available_categories]\n        \n        return {\n            \"wildcards_used\": wildcards_used,\n            \"valid_wildcards\": valid_wildcards,\n            \"invalid_wildcards\": invalid_wildcards,\n            \"total_combinations\": self._calculate_combinations(valid_wildcards)\n        }\n    \n    def _calculate_combinations(self, wildcards: List[str]) -> int:\n        \"\"\"Calculate total possible combinations.\"\"\"\n        total = 1\n        for wildcard in wildcards:\n            if wildcard in self.wildcards_data:\n                total *= len(self.wildcards_data[wildcard])\n        return total